##' Computes the (binary) vulnerability matrix
##'
##' The function computes a vulnerability matrix given
##' a network of bilateral exposures and a vector of capital buffers. The vulnerability
##' matrix represents how much a vertex impacts the capital buffer of another vertex
##' if it defaults.
##'
##'
##' @param exposures an adjacency \code{\link{matrix}} or an \code{\link{igraph}}
##' object with the network of bilateral exposures between vertices. By default, the function
##' expects the exposures in the form of an assets matrix
##' in which A -> B means that A has an asset with B. However, you can
##' change that with the parameter \code{exposure_type}. When using a matrix, preferably it should have
##' rows and columns names.
##'
##' @param capital_buffer a numeric vector with the capital buffer for each vertex.
##' Values should be in the same row/column order as the network of bilateral exposures. This
##' parameter is not needed if \code{exposure_type = "vulnerability"}.
##'
##' @param binary if \code{binary = TRUE} it computes the binary vulnerability matrix,
##' truncating all values less than 1 to 0.
##'
##' @param exposure_type character vector indicating the type of the bilateral exposures. It can be
##' an "assets" network (where A -> B means that A has an asset with B),
##' a "liabilities" network (where A -> B means that A has a debt with B) or
##' it can be a (binary) "vulnerability" matrix (where A -> B indicates the relative impact
##'  of A in B's capital buffer).For the last option see \code{\link{vulnerability_matrix}}.
##'  The default is "assets".
##'
##' @return The function returns a (binary) vulnerability matrix.
##'
##' The term V[i,j] of the vulnerability matrix represents
##' the impact of i's default in j's capital buffer. If \code{binary = TRUE}
##' the values less than 1 are truncated to zero.
##'
##' @examples
##' # Creating example data
##' ## Assets Matrix (bilateral exposures)
##' assets_matrix <- matrix(c(0, 10, 3, 1, 0, 2, 0, 3, 0), ncol = 3)
##' rownames(assets_matrix) <- colnames(assets_matrix) <- letters[1:3]
##'
##' ## Capital Buffer
##' buffer <- c(a = 2, b = 5, c = 2)
##'
##' # Vulnerability matrices
##' vulnerability_matrix(assets_matrix, buffer, binary = FALSE)
##' vulnerability_matrix(assets_matrix, buffer, binary = TRUE)
##'
##' @export
vulnerability_matrix <- function(exposures,
                                 capital_buffer,
                                 binary = TRUE,
                                 exposure_type = c("assets", "liabilities", "vulnerability")){
  UseMethod("vulnerability_matrix")
}

##' @export
vulnerability_matrix.igraph <- function(exposures,
                                        capital_buffer,
                                        binary = TRUE,
                                        exposure_type = c("assets", "liabilities", "vulnerability")){
  exposures <- exposures[,]
  vulnerability_matrix(exposures,
                        capital_buffer,
                        binary = binary,
                       exposure_type = exposure_type)
}

##' @export
vulnerability_matrix.default <- function(exposures,
                                 capital_buffer,
                                 binary = TRUE,
                                 exposure_type = c("assets", "liabilities", "vulnerability")) {


  exposure_type = match.arg(exposure_type)

  exposures <- rowcolnames(exposures)

  if (exposure_type == "vulnerability"){
    if (binary) exposures <- (exposures >= 1)*1
    return(exposures)
  }

  if (exposure_type == "liabilities") exposures <- t(exposures)

  vulnerability_matrix <- exposures / capital_buffer
  vulnerability_matrix <- t(vulnerability_matrix)
  vulnerability_matrix[vulnerability_matrix > 1] <- 1

  if (binary) vulnerability_matrix <- (vulnerability_matrix >= 1)*1

  return(vulnerability_matrix)
}

# checks for rownames or colnames in a matrix
rowcolnames <- function(exposures){

  if(is.null(rownames(exposures)) & !is.null(colnames(exposures))){
    rownames(exposures) <- colnames(exposures)
    warning("No rownames found, colnames used as rownames.")
  }

  if(!is.null(rownames(exposures)) & is.null(colnames(exposures))){
    colnames(exposures) <- rownames(exposures)
    warning("No colnames found, rownames used as colnames")
  }

  if(is.null(rownames(exposures)) & is.null(colnames(exposures))){
    rownames(exposures) <- colnames(exposures) <- 1:nrow(exposures)
    warning("No rownames or colnames found.")
  }

  return(exposures)
}
##' Computes the communicability matrix
##'
##' The communicability of an adjacency matrix M is defined as exp(M) where
##' M[i,j] can be interpreted as the weighted sums of paths from i to j. The function
##' computes the communicability matrix using the exponential or
##' using an approximation with a defined number of terms.
##'
##' @param x a \code{\link{matrix}} or an \code{\link{igraph}} object.
##'
##' @param terms truncates the communicability matrix evaluation to the number of terms.
##' If \code{Inf} it calculates the matrix exponential using \code{\link{expm}}.
##'
##' @param sparse should it use sparse matrices when computing the communicability? However, if \code{terms = Inf}
##' the function will use \code{\link{expm}} which uses \code{\link{dgeMatrix-class}}.
##'
##' @return The function returns the communicability matrix.
##'
##' @examples
##' # Creating example data
##' ## Assets Matrix (bilateral exposures)
##' assets_matrix <- matrix(c(0, 10, 3, 1, 0, 2, 0, 3, 0), ncol = 3)
##' rownames(assets_matrix) <- colnames(assets_matrix) <- letters[1:3]
##'
##' ## Capital Buffer
##' buffer <- c(a = 2, b = 5, c = 2)
##'
##' # Computing vulnerability
##' v <- vulnerability_matrix(assets_matrix, buffer, binary = TRUE)
##'
##' # Computing communicability of the vulnerability matrix
##' communicability_matrix(v)
##'
##' @references
##' Estrada, E. Hatano, N. (2008). Communicability in complex networks.
##' Physical Review E, 77:036111.
##'
##' @export
##'
##'@import Matrix 
communicability_matrix <- function(x,
                                   terms = Inf,
                                   sparse = TRUE){
  UseMethod("communicability_matrix")
}


##' @export
communicability_matrix.igraph <- function(x,
                                          terms = Inf,
                                          sparse = TRUE){
  x <- x[,]
  communicability_matrix(x = x,
                         terms = terms,
                         sparse = sparse)
}

##' @export
communicability_matrix.default <- function(x,
                                   terms = Inf,
                                   sparse = TRUE){

  if (is.infinite(terms)) {
    return(expm(x))
  }

  if (sparse) {
    id <- Matrix(0, nrow = nrow(x), ncol = ncol(x))
    diag(id) <- 1
  }else {
    id <- diag(1, nrow = nrow(x), ncol = ncol(x))
  }

  c <- id
  aux <- id
  for (i in 1:terms) {
    aux <- aux %*% x
    c <- c + aux / factorial(i)
  }

  rownames(c) <- rownames(x)
  colnames(c) <- colnames(x)
  return(c)
}
